// Generated by Molecule 0.8.0

use super::blockchain::*;
use super::fiber::*;
use molecule::prelude::*;
#[derive(Clone)]
pub struct Uint16(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Uint16 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Uint16::new_unchecked(v)
    }
}
impl Uint16 {
    const DEFAULT_VALUE: [u8; 2] = [0, 0];
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Uint16Reader<'r> {
        Uint16Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint16 {
    type Builder = Uint16Builder;
    const NAME: &'static str = "Uint16";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint16(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint16Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint16Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
#[derive(Clone, Copy)]
pub struct Uint16Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint16Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint16Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint16Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Uint16Reader<'r> {
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint16Reader<'r> {
    type Entity = Uint16;
    const NAME: &'static str = "Uint16Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint16Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Uint16Builder(pub(crate) [Byte; 2]);
impl ::core::fmt::Debug for Uint16Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Uint16Builder {
    fn default() -> Self {
        Uint16Builder([Byte::default(), Byte::default()])
    }
}
impl Uint16Builder {
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn set(mut self, v: [Byte; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
}
impl molecule::prelude::Builder for Uint16Builder {
    type Entity = Uint16;
    const NAME: &'static str = "Uint16Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint16::new_unchecked(inner.into())
    }
}
impl From<[Byte; 2usize]> for Uint16 {
    fn from(value: [Byte; 2usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for Uint16 {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 2usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<Uint16> for [Byte; 2usize] {
    #[track_caller]
    fn from(value: Uint16) -> Self {
        [value.nth0(), value.nth1()]
    }
}
impl From<[u8; 2usize]> for Uint16 {
    fn from(value: [u8; 2usize]) -> Self {
        Uint16Reader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for Uint16 {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 2usize]>::try_from(value)?.into())
    }
}
impl From<Uint16> for [u8; 2usize] {
    #[track_caller]
    fn from(value: Uint16) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<Uint16Reader<'a>> for &'a [u8; 2usize] {
    #[track_caller]
    fn from(value: Uint16Reader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a Uint16Reader<'a>> for &'a [u8; 2usize] {
    #[track_caller]
    fn from(value: &'a Uint16Reader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct Cursor(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Cursor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Cursor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Cursor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Cursor {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Cursor::new_unchecked(v)
    }
}
impl Cursor {
    const DEFAULT_VALUE: [u8; 45] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 45;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 45;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn nth32(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(32..33))
    }
    pub fn nth33(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(33..34))
    }
    pub fn nth34(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(34..35))
    }
    pub fn nth35(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(35..36))
    }
    pub fn nth36(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(36..37))
    }
    pub fn nth37(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(37..38))
    }
    pub fn nth38(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(38..39))
    }
    pub fn nth39(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(39..40))
    }
    pub fn nth40(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(40..41))
    }
    pub fn nth41(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(41..42))
    }
    pub fn nth42(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(42..43))
    }
    pub fn nth43(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(43..44))
    }
    pub fn nth44(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(44..45))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> CursorReader<'r> {
        CursorReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Cursor {
    type Builder = CursorBuilder;
    const NAME: &'static str = "Cursor";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Cursor(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CursorReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CursorReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
            self.nth33(),
            self.nth34(),
            self.nth35(),
            self.nth36(),
            self.nth37(),
            self.nth38(),
            self.nth39(),
            self.nth40(),
            self.nth41(),
            self.nth42(),
            self.nth43(),
            self.nth44(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct CursorReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CursorReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CursorReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CursorReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> CursorReader<'r> {
    pub const TOTAL_SIZE: usize = 45;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 45;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn nth32(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[32..33])
    }
    pub fn nth33(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[33..34])
    }
    pub fn nth34(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[34..35])
    }
    pub fn nth35(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[35..36])
    }
    pub fn nth36(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[36..37])
    }
    pub fn nth37(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[37..38])
    }
    pub fn nth38(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[38..39])
    }
    pub fn nth39(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[39..40])
    }
    pub fn nth40(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[40..41])
    }
    pub fn nth41(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[41..42])
    }
    pub fn nth42(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[42..43])
    }
    pub fn nth43(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[43..44])
    }
    pub fn nth44(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[44..45])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for CursorReader<'r> {
    type Entity = Cursor;
    const NAME: &'static str = "CursorReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CursorReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct CursorBuilder(pub(crate) [Byte; 45]);
impl ::core::fmt::Debug for CursorBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for CursorBuilder {
    fn default() -> Self {
        CursorBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl CursorBuilder {
    pub const TOTAL_SIZE: usize = 45;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 45;
    pub fn set(mut self, v: [Byte; 45]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
    pub fn nth32(mut self, v: Byte) -> Self {
        self.0[32] = v;
        self
    }
    pub fn nth33(mut self, v: Byte) -> Self {
        self.0[33] = v;
        self
    }
    pub fn nth34(mut self, v: Byte) -> Self {
        self.0[34] = v;
        self
    }
    pub fn nth35(mut self, v: Byte) -> Self {
        self.0[35] = v;
        self
    }
    pub fn nth36(mut self, v: Byte) -> Self {
        self.0[36] = v;
        self
    }
    pub fn nth37(mut self, v: Byte) -> Self {
        self.0[37] = v;
        self
    }
    pub fn nth38(mut self, v: Byte) -> Self {
        self.0[38] = v;
        self
    }
    pub fn nth39(mut self, v: Byte) -> Self {
        self.0[39] = v;
        self
    }
    pub fn nth40(mut self, v: Byte) -> Self {
        self.0[40] = v;
        self
    }
    pub fn nth41(mut self, v: Byte) -> Self {
        self.0[41] = v;
        self
    }
    pub fn nth42(mut self, v: Byte) -> Self {
        self.0[42] = v;
        self
    }
    pub fn nth43(mut self, v: Byte) -> Self {
        self.0[43] = v;
        self
    }
    pub fn nth44(mut self, v: Byte) -> Self {
        self.0[44] = v;
        self
    }
}
impl molecule::prelude::Builder for CursorBuilder {
    type Entity = Cursor;
    const NAME: &'static str = "CursorBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        writer.write_all(self.0[33].as_slice())?;
        writer.write_all(self.0[34].as_slice())?;
        writer.write_all(self.0[35].as_slice())?;
        writer.write_all(self.0[36].as_slice())?;
        writer.write_all(self.0[37].as_slice())?;
        writer.write_all(self.0[38].as_slice())?;
        writer.write_all(self.0[39].as_slice())?;
        writer.write_all(self.0[40].as_slice())?;
        writer.write_all(self.0[41].as_slice())?;
        writer.write_all(self.0[42].as_slice())?;
        writer.write_all(self.0[43].as_slice())?;
        writer.write_all(self.0[44].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Cursor::new_unchecked(inner.into())
    }
}
impl From<[Byte; 45usize]> for Cursor {
    fn from(value: [Byte; 45usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for Cursor {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 45usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<Cursor> for [Byte; 45usize] {
    #[track_caller]
    fn from(value: Cursor) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
            value.nth12(),
            value.nth13(),
            value.nth14(),
            value.nth15(),
            value.nth16(),
            value.nth17(),
            value.nth18(),
            value.nth19(),
            value.nth20(),
            value.nth21(),
            value.nth22(),
            value.nth23(),
            value.nth24(),
            value.nth25(),
            value.nth26(),
            value.nth27(),
            value.nth28(),
            value.nth29(),
            value.nth30(),
            value.nth31(),
            value.nth32(),
            value.nth33(),
            value.nth34(),
            value.nth35(),
            value.nth36(),
            value.nth37(),
            value.nth38(),
            value.nth39(),
            value.nth40(),
            value.nth41(),
            value.nth42(),
            value.nth43(),
            value.nth44(),
        ]
    }
}
impl From<[u8; 45usize]> for Cursor {
    fn from(value: [u8; 45usize]) -> Self {
        CursorReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for Cursor {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 45usize]>::try_from(value)?.into())
    }
}
impl From<Cursor> for [u8; 45usize] {
    #[track_caller]
    fn from(value: Cursor) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<CursorReader<'a>> for &'a [u8; 45usize] {
    #[track_caller]
    fn from(value: CursorReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a CursorReader<'a>> for &'a [u8; 45usize] {
    #[track_caller]
    fn from(value: &'a CursorReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct BroadcastMessagesFilter(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BroadcastMessagesFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BroadcastMessagesFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BroadcastMessagesFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "after_cursor", self.after_cursor())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BroadcastMessagesFilter {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BroadcastMessagesFilter::new_unchecked(v)
    }
}
impl BroadcastMessagesFilter {
    const DEFAULT_VALUE: [u8; 89] = [
        89, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn chain_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn after_cursor(&self) -> Cursor {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Cursor::new_unchecked(self.0.slice(start..end))
        } else {
            Cursor::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BroadcastMessagesFilterReader<'r> {
        BroadcastMessagesFilterReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BroadcastMessagesFilter {
    type Builder = BroadcastMessagesFilterBuilder;
    const NAME: &'static str = "BroadcastMessagesFilter";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BroadcastMessagesFilter(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessagesFilterReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessagesFilterReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .chain_hash(self.chain_hash())
            .after_cursor(self.after_cursor())
    }
}
#[derive(Clone, Copy)]
pub struct BroadcastMessagesFilterReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BroadcastMessagesFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BroadcastMessagesFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BroadcastMessagesFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "after_cursor", self.after_cursor())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BroadcastMessagesFilterReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn chain_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn after_cursor(&self) -> CursorReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            CursorReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            CursorReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BroadcastMessagesFilterReader<'r> {
    type Entity = BroadcastMessagesFilter;
    const NAME: &'static str = "BroadcastMessagesFilterReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BroadcastMessagesFilterReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        CursorReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BroadcastMessagesFilterBuilder {
    pub(crate) chain_hash: Byte32,
    pub(crate) after_cursor: Cursor,
}
impl BroadcastMessagesFilterBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn chain_hash(mut self, v: Byte32) -> Self {
        self.chain_hash = v;
        self
    }
    pub fn after_cursor(mut self, v: Cursor) -> Self {
        self.after_cursor = v;
        self
    }
}
impl molecule::prelude::Builder for BroadcastMessagesFilterBuilder {
    type Entity = BroadcastMessagesFilter;
    const NAME: &'static str = "BroadcastMessagesFilterBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.chain_hash.as_slice().len()
            + self.after_cursor.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.chain_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.after_cursor.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.chain_hash.as_slice())?;
        writer.write_all(self.after_cursor.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BroadcastMessagesFilter::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBroadcastMessages(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBroadcastMessages {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBroadcastMessages {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBroadcastMessages {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "after_cursor", self.after_cursor())?;
        write!(f, ", {}: {}", "count", self.count())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBroadcastMessages {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetBroadcastMessages::new_unchecked(v)
    }
}
impl GetBroadcastMessages {
    const DEFAULT_VALUE: [u8; 107] = [
        107, 0, 0, 0, 20, 0, 0, 0, 28, 0, 0, 0, 60, 0, 0, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn chain_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn after_cursor(&self) -> Cursor {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Cursor::new_unchecked(self.0.slice(start..end))
    }
    pub fn count(&self) -> Uint16 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Uint16::new_unchecked(self.0.slice(start..end))
        } else {
            Uint16::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetBroadcastMessagesReader<'r> {
        GetBroadcastMessagesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBroadcastMessages {
    type Builder = GetBroadcastMessagesBuilder;
    const NAME: &'static str = "GetBroadcastMessages";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBroadcastMessages(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBroadcastMessagesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBroadcastMessagesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .id(self.id())
            .chain_hash(self.chain_hash())
            .after_cursor(self.after_cursor())
            .count(self.count())
    }
}
#[derive(Clone, Copy)]
pub struct GetBroadcastMessagesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBroadcastMessagesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBroadcastMessagesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBroadcastMessagesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "after_cursor", self.after_cursor())?;
        write!(f, ", {}: {}", "count", self.count())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetBroadcastMessagesReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn chain_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn after_cursor(&self) -> CursorReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        CursorReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn count(&self) -> Uint16Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Uint16Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint16Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBroadcastMessagesReader<'r> {
    type Entity = GetBroadcastMessages;
    const NAME: &'static str = "GetBroadcastMessagesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBroadcastMessagesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        CursorReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint16Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct GetBroadcastMessagesBuilder {
    pub(crate) id: Uint64,
    pub(crate) chain_hash: Byte32,
    pub(crate) after_cursor: Cursor,
    pub(crate) count: Uint16,
}
impl GetBroadcastMessagesBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn id(mut self, v: Uint64) -> Self {
        self.id = v;
        self
    }
    pub fn chain_hash(mut self, v: Byte32) -> Self {
        self.chain_hash = v;
        self
    }
    pub fn after_cursor(mut self, v: Cursor) -> Self {
        self.after_cursor = v;
        self
    }
    pub fn count(mut self, v: Uint16) -> Self {
        self.count = v;
        self
    }
}
impl molecule::prelude::Builder for GetBroadcastMessagesBuilder {
    type Entity = GetBroadcastMessages;
    const NAME: &'static str = "GetBroadcastMessagesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.id.as_slice().len()
            + self.chain_hash.as_slice().len()
            + self.after_cursor.as_slice().len()
            + self.count.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.chain_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.after_cursor.as_slice().len();
        offsets.push(total_size);
        total_size += self.count.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.chain_hash.as_slice())?;
        writer.write_all(self.after_cursor.as_slice())?;
        writer.write_all(self.count.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBroadcastMessages::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct NodeAnnouncementQuery(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NodeAnnouncementQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NodeAnnouncementQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NodeAnnouncementQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "node_id", self.node_id())?;
        write!(f, ", {}: {}", "flags", self.flags())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for NodeAnnouncementQuery {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        NodeAnnouncementQuery::new_unchecked(v)
    }
}
impl NodeAnnouncementQuery {
    const DEFAULT_VALUE: [u8; 34] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 34;
    pub const FIELD_SIZES: [usize; 2] = [33, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn node_id(&self) -> Pubkey {
        Pubkey::new_unchecked(self.0.slice(0..33))
    }
    pub fn flags(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(33..34))
    }
    pub fn as_reader<'r>(&'r self) -> NodeAnnouncementQueryReader<'r> {
        NodeAnnouncementQueryReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NodeAnnouncementQuery {
    type Builder = NodeAnnouncementQueryBuilder;
    const NAME: &'static str = "NodeAnnouncementQuery";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NodeAnnouncementQuery(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodeAnnouncementQueryReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodeAnnouncementQueryReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .node_id(self.node_id())
            .flags(self.flags())
    }
}
#[derive(Clone, Copy)]
pub struct NodeAnnouncementQueryReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NodeAnnouncementQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NodeAnnouncementQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NodeAnnouncementQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "node_id", self.node_id())?;
        write!(f, ", {}: {}", "flags", self.flags())?;
        write!(f, " }}")
    }
}
impl<'r> NodeAnnouncementQueryReader<'r> {
    pub const TOTAL_SIZE: usize = 34;
    pub const FIELD_SIZES: [usize; 2] = [33, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn node_id(&self) -> PubkeyReader<'r> {
        PubkeyReader::new_unchecked(&self.as_slice()[0..33])
    }
    pub fn flags(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[33..34])
    }
}
impl<'r> molecule::prelude::Reader<'r> for NodeAnnouncementQueryReader<'r> {
    type Entity = NodeAnnouncementQuery;
    const NAME: &'static str = "NodeAnnouncementQueryReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NodeAnnouncementQueryReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct NodeAnnouncementQueryBuilder {
    pub(crate) node_id: Pubkey,
    pub(crate) flags: Byte,
}
impl NodeAnnouncementQueryBuilder {
    pub const TOTAL_SIZE: usize = 34;
    pub const FIELD_SIZES: [usize; 2] = [33, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn node_id(mut self, v: Pubkey) -> Self {
        self.node_id = v;
        self
    }
    pub fn flags(mut self, v: Byte) -> Self {
        self.flags = v;
        self
    }
}
impl molecule::prelude::Builder for NodeAnnouncementQueryBuilder {
    type Entity = NodeAnnouncementQuery;
    const NAME: &'static str = "NodeAnnouncementQueryBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.node_id.as_slice())?;
        writer.write_all(self.flags.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NodeAnnouncementQuery::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelAnnouncementQuery(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelAnnouncementQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelAnnouncementQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelAnnouncementQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "flags", self.flags())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelAnnouncementQuery {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ChannelAnnouncementQuery::new_unchecked(v)
    }
}
impl ChannelAnnouncementQuery {
    const DEFAULT_VALUE: [u8; 37] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 37;
    pub const FIELD_SIZES: [usize; 2] = [36, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_outpoint(&self) -> OutPoint {
        OutPoint::new_unchecked(self.0.slice(0..36))
    }
    pub fn flags(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(36..37))
    }
    pub fn as_reader<'r>(&'r self) -> ChannelAnnouncementQueryReader<'r> {
        ChannelAnnouncementQueryReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelAnnouncementQuery {
    type Builder = ChannelAnnouncementQueryBuilder;
    const NAME: &'static str = "ChannelAnnouncementQuery";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelAnnouncementQuery(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelAnnouncementQueryReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelAnnouncementQueryReader::from_compatible_slice(slice)
            .map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_outpoint(self.channel_outpoint())
            .flags(self.flags())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelAnnouncementQueryReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelAnnouncementQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelAnnouncementQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelAnnouncementQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "flags", self.flags())?;
        write!(f, " }}")
    }
}
impl<'r> ChannelAnnouncementQueryReader<'r> {
    pub const TOTAL_SIZE: usize = 37;
    pub const FIELD_SIZES: [usize; 2] = [36, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_outpoint(&self) -> OutPointReader<'r> {
        OutPointReader::new_unchecked(&self.as_slice()[0..36])
    }
    pub fn flags(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[36..37])
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelAnnouncementQueryReader<'r> {
    type Entity = ChannelAnnouncementQuery;
    const NAME: &'static str = "ChannelAnnouncementQueryReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelAnnouncementQueryReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ChannelAnnouncementQueryBuilder {
    pub(crate) channel_outpoint: OutPoint,
    pub(crate) flags: Byte,
}
impl ChannelAnnouncementQueryBuilder {
    pub const TOTAL_SIZE: usize = 37;
    pub const FIELD_SIZES: [usize; 2] = [36, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_outpoint(mut self, v: OutPoint) -> Self {
        self.channel_outpoint = v;
        self
    }
    pub fn flags(mut self, v: Byte) -> Self {
        self.flags = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelAnnouncementQueryBuilder {
    type Entity = ChannelAnnouncementQuery;
    const NAME: &'static str = "ChannelAnnouncementQueryBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.channel_outpoint.as_slice())?;
        writer.write_all(self.flags.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelAnnouncementQuery::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelUpdateQuery(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelUpdateQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelUpdateQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelUpdateQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "flags", self.flags())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelUpdateQuery {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ChannelUpdateQuery::new_unchecked(v)
    }
}
impl ChannelUpdateQuery {
    const DEFAULT_VALUE: [u8; 37] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 37;
    pub const FIELD_SIZES: [usize; 2] = [36, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_outpoint(&self) -> OutPoint {
        OutPoint::new_unchecked(self.0.slice(0..36))
    }
    pub fn flags(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(36..37))
    }
    pub fn as_reader<'r>(&'r self) -> ChannelUpdateQueryReader<'r> {
        ChannelUpdateQueryReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelUpdateQuery {
    type Builder = ChannelUpdateQueryBuilder;
    const NAME: &'static str = "ChannelUpdateQuery";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelUpdateQuery(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelUpdateQueryReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelUpdateQueryReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_outpoint(self.channel_outpoint())
            .flags(self.flags())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelUpdateQueryReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelUpdateQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelUpdateQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelUpdateQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "flags", self.flags())?;
        write!(f, " }}")
    }
}
impl<'r> ChannelUpdateQueryReader<'r> {
    pub const TOTAL_SIZE: usize = 37;
    pub const FIELD_SIZES: [usize; 2] = [36, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_outpoint(&self) -> OutPointReader<'r> {
        OutPointReader::new_unchecked(&self.as_slice()[0..36])
    }
    pub fn flags(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[36..37])
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelUpdateQueryReader<'r> {
    type Entity = ChannelUpdateQuery;
    const NAME: &'static str = "ChannelUpdateQueryReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelUpdateQueryReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ChannelUpdateQueryBuilder {
    pub(crate) channel_outpoint: OutPoint,
    pub(crate) flags: Byte,
}
impl ChannelUpdateQueryBuilder {
    pub const TOTAL_SIZE: usize = 37;
    pub const FIELD_SIZES: [usize; 2] = [36, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn channel_outpoint(mut self, v: OutPoint) -> Self {
        self.channel_outpoint = v;
        self
    }
    pub fn flags(mut self, v: Byte) -> Self {
        self.flags = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelUpdateQueryBuilder {
    type Entity = ChannelUpdateQuery;
    const NAME: &'static str = "ChannelUpdateQueryBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.channel_outpoint.as_slice())?;
        writer.write_all(self.flags.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelUpdateQuery::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BroadcastMessageQuery(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BroadcastMessageQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BroadcastMessageQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BroadcastMessageQuery {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for BroadcastMessageQuery {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BroadcastMessageQuery::new_unchecked(v)
    }
}
impl BroadcastMessageQuery {
    const DEFAULT_VALUE: [u8; 38] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BroadcastMessageQueryUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => NodeAnnouncementQuery::new_unchecked(inner).into(),
            1 => ChannelAnnouncementQuery::new_unchecked(inner).into(),
            2 => ChannelUpdateQuery::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> BroadcastMessageQueryReader<'r> {
        BroadcastMessageQueryReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BroadcastMessageQuery {
    type Builder = BroadcastMessageQueryBuilder;
    const NAME: &'static str = "BroadcastMessageQuery";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BroadcastMessageQuery(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessageQueryReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessageQueryReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct BroadcastMessageQueryReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BroadcastMessageQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BroadcastMessageQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BroadcastMessageQueryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> BroadcastMessageQueryReader<'r> {
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BroadcastMessageQueryUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => NodeAnnouncementQueryReader::new_unchecked(inner).into(),
            1 => ChannelAnnouncementQueryReader::new_unchecked(inner).into(),
            2 => ChannelUpdateQueryReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BroadcastMessageQueryReader<'r> {
    type Entity = BroadcastMessageQuery;
    const NAME: &'static str = "BroadcastMessageQueryReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BroadcastMessageQueryReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => NodeAnnouncementQueryReader::verify(inner_slice, compatible),
            1 => ChannelAnnouncementQueryReader::verify(inner_slice, compatible),
            2 => ChannelUpdateQueryReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BroadcastMessageQueryBuilder(pub(crate) BroadcastMessageQueryUnion);
impl BroadcastMessageQueryBuilder {
    pub const ITEMS_COUNT: usize = 3;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<BroadcastMessageQueryUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for BroadcastMessageQueryBuilder {
    type Entity = BroadcastMessageQuery;
    const NAME: &'static str = "BroadcastMessageQueryBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BroadcastMessageQuery::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum BroadcastMessageQueryUnion {
    NodeAnnouncementQuery(NodeAnnouncementQuery),
    ChannelAnnouncementQuery(ChannelAnnouncementQuery),
    ChannelUpdateQuery(ChannelUpdateQuery),
}
#[derive(Debug, Clone, Copy)]
pub enum BroadcastMessageQueryUnionReader<'r> {
    NodeAnnouncementQuery(NodeAnnouncementQueryReader<'r>),
    ChannelAnnouncementQuery(ChannelAnnouncementQueryReader<'r>),
    ChannelUpdateQuery(ChannelUpdateQueryReader<'r>),
}
impl ::core::default::Default for BroadcastMessageQueryUnion {
    fn default() -> Self {
        BroadcastMessageQueryUnion::NodeAnnouncementQuery(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for BroadcastMessageQueryUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BroadcastMessageQueryUnion::NodeAnnouncementQuery(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    NodeAnnouncementQuery::NAME,
                    item
                )
            }
            BroadcastMessageQueryUnion::ChannelAnnouncementQuery(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    ChannelAnnouncementQuery::NAME,
                    item
                )
            }
            BroadcastMessageQueryUnion::ChannelUpdateQuery(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ChannelUpdateQuery::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for BroadcastMessageQueryUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BroadcastMessageQueryUnionReader::NodeAnnouncementQuery(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    NodeAnnouncementQuery::NAME,
                    item
                )
            }
            BroadcastMessageQueryUnionReader::ChannelAnnouncementQuery(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    ChannelAnnouncementQuery::NAME,
                    item
                )
            }
            BroadcastMessageQueryUnionReader::ChannelUpdateQuery(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ChannelUpdateQuery::NAME, item)
            }
        }
    }
}
impl BroadcastMessageQueryUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BroadcastMessageQueryUnion::NodeAnnouncementQuery(ref item) => write!(f, "{}", item),
            BroadcastMessageQueryUnion::ChannelAnnouncementQuery(ref item) => write!(f, "{}", item),
            BroadcastMessageQueryUnion::ChannelUpdateQuery(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> BroadcastMessageQueryUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BroadcastMessageQueryUnionReader::NodeAnnouncementQuery(ref item) => {
                write!(f, "{}", item)
            }
            BroadcastMessageQueryUnionReader::ChannelAnnouncementQuery(ref item) => {
                write!(f, "{}", item)
            }
            BroadcastMessageQueryUnionReader::ChannelUpdateQuery(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<NodeAnnouncementQuery> for BroadcastMessageQueryUnion {
    fn from(item: NodeAnnouncementQuery) -> Self {
        BroadcastMessageQueryUnion::NodeAnnouncementQuery(item)
    }
}
impl ::core::convert::From<ChannelAnnouncementQuery> for BroadcastMessageQueryUnion {
    fn from(item: ChannelAnnouncementQuery) -> Self {
        BroadcastMessageQueryUnion::ChannelAnnouncementQuery(item)
    }
}
impl ::core::convert::From<ChannelUpdateQuery> for BroadcastMessageQueryUnion {
    fn from(item: ChannelUpdateQuery) -> Self {
        BroadcastMessageQueryUnion::ChannelUpdateQuery(item)
    }
}
impl<'r> ::core::convert::From<NodeAnnouncementQueryReader<'r>>
    for BroadcastMessageQueryUnionReader<'r>
{
    fn from(item: NodeAnnouncementQueryReader<'r>) -> Self {
        BroadcastMessageQueryUnionReader::NodeAnnouncementQuery(item)
    }
}
impl<'r> ::core::convert::From<ChannelAnnouncementQueryReader<'r>>
    for BroadcastMessageQueryUnionReader<'r>
{
    fn from(item: ChannelAnnouncementQueryReader<'r>) -> Self {
        BroadcastMessageQueryUnionReader::ChannelAnnouncementQuery(item)
    }
}
impl<'r> ::core::convert::From<ChannelUpdateQueryReader<'r>>
    for BroadcastMessageQueryUnionReader<'r>
{
    fn from(item: ChannelUpdateQueryReader<'r>) -> Self {
        BroadcastMessageQueryUnionReader::ChannelUpdateQuery(item)
    }
}
impl BroadcastMessageQueryUnion {
    pub const NAME: &'static str = "BroadcastMessageQueryUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            BroadcastMessageQueryUnion::NodeAnnouncementQuery(item) => item.as_bytes(),
            BroadcastMessageQueryUnion::ChannelAnnouncementQuery(item) => item.as_bytes(),
            BroadcastMessageQueryUnion::ChannelUpdateQuery(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            BroadcastMessageQueryUnion::NodeAnnouncementQuery(item) => item.as_slice(),
            BroadcastMessageQueryUnion::ChannelAnnouncementQuery(item) => item.as_slice(),
            BroadcastMessageQueryUnion::ChannelUpdateQuery(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BroadcastMessageQueryUnion::NodeAnnouncementQuery(_) => 0,
            BroadcastMessageQueryUnion::ChannelAnnouncementQuery(_) => 1,
            BroadcastMessageQueryUnion::ChannelUpdateQuery(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BroadcastMessageQueryUnion::NodeAnnouncementQuery(_) => "NodeAnnouncementQuery",
            BroadcastMessageQueryUnion::ChannelAnnouncementQuery(_) => "ChannelAnnouncementQuery",
            BroadcastMessageQueryUnion::ChannelUpdateQuery(_) => "ChannelUpdateQuery",
        }
    }
    pub fn as_reader<'r>(&'r self) -> BroadcastMessageQueryUnionReader<'r> {
        match self {
            BroadcastMessageQueryUnion::NodeAnnouncementQuery(item) => item.as_reader().into(),
            BroadcastMessageQueryUnion::ChannelAnnouncementQuery(item) => item.as_reader().into(),
            BroadcastMessageQueryUnion::ChannelUpdateQuery(item) => item.as_reader().into(),
        }
    }
}
impl<'r> BroadcastMessageQueryUnionReader<'r> {
    pub const NAME: &'r str = "BroadcastMessageQueryUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            BroadcastMessageQueryUnionReader::NodeAnnouncementQuery(item) => item.as_slice(),
            BroadcastMessageQueryUnionReader::ChannelAnnouncementQuery(item) => item.as_slice(),
            BroadcastMessageQueryUnionReader::ChannelUpdateQuery(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BroadcastMessageQueryUnionReader::NodeAnnouncementQuery(_) => 0,
            BroadcastMessageQueryUnionReader::ChannelAnnouncementQuery(_) => 1,
            BroadcastMessageQueryUnionReader::ChannelUpdateQuery(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BroadcastMessageQueryUnionReader::NodeAnnouncementQuery(_) => "NodeAnnouncementQuery",
            BroadcastMessageQueryUnionReader::ChannelAnnouncementQuery(_) => {
                "ChannelAnnouncementQuery"
            }
            BroadcastMessageQueryUnionReader::ChannelUpdateQuery(_) => "ChannelUpdateQuery",
        }
    }
}
impl From<NodeAnnouncementQuery> for BroadcastMessageQuery {
    fn from(value: NodeAnnouncementQuery) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<ChannelAnnouncementQuery> for BroadcastMessageQuery {
    fn from(value: ChannelAnnouncementQuery) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<ChannelUpdateQuery> for BroadcastMessageQuery {
    fn from(value: ChannelUpdateQuery) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct BroadcastMessageQueries(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BroadcastMessageQueries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BroadcastMessageQueries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BroadcastMessageQueries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for BroadcastMessageQueries {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BroadcastMessageQueries::new_unchecked(v)
    }
}
impl BroadcastMessageQueries {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<BroadcastMessageQuery> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> BroadcastMessageQuery {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            BroadcastMessageQuery::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            BroadcastMessageQuery::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BroadcastMessageQueriesReader<'r> {
        BroadcastMessageQueriesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BroadcastMessageQueries {
    type Builder = BroadcastMessageQueriesBuilder;
    const NAME: &'static str = "BroadcastMessageQueries";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BroadcastMessageQueries(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessageQueriesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessageQueriesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct BroadcastMessageQueriesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BroadcastMessageQueriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BroadcastMessageQueriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BroadcastMessageQueriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> BroadcastMessageQueriesReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<BroadcastMessageQueryReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> BroadcastMessageQueryReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            BroadcastMessageQueryReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            BroadcastMessageQueryReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BroadcastMessageQueriesReader<'r> {
    type Entity = BroadcastMessageQueries;
    const NAME: &'static str = "BroadcastMessageQueriesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BroadcastMessageQueriesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            BroadcastMessageQueryReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BroadcastMessageQueriesBuilder(pub(crate) Vec<BroadcastMessageQuery>);
impl BroadcastMessageQueriesBuilder {
    pub fn set(mut self, v: Vec<BroadcastMessageQuery>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: BroadcastMessageQuery) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = BroadcastMessageQuery>>(
        mut self,
        iter: T,
    ) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(
        &mut self,
        index: usize,
        v: BroadcastMessageQuery,
    ) -> Option<BroadcastMessageQuery> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for BroadcastMessageQueriesBuilder {
    type Entity = BroadcastMessageQueries;
    const NAME: &'static str = "BroadcastMessageQueriesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BroadcastMessageQueries::new_unchecked(inner.into())
    }
}
pub struct BroadcastMessageQueriesIterator(BroadcastMessageQueries, usize, usize);
impl ::core::iter::Iterator for BroadcastMessageQueriesIterator {
    type Item = BroadcastMessageQuery;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for BroadcastMessageQueriesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for BroadcastMessageQueries {
    type Item = BroadcastMessageQuery;
    type IntoIter = BroadcastMessageQueriesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BroadcastMessageQueriesIterator(self, 0, len)
    }
}
impl<'r> BroadcastMessageQueriesReader<'r> {
    pub fn iter<'t>(&'t self) -> BroadcastMessageQueriesReaderIterator<'t, 'r> {
        BroadcastMessageQueriesReaderIterator(&self, 0, self.len())
    }
}
pub struct BroadcastMessageQueriesReaderIterator<'t, 'r>(
    &'t BroadcastMessageQueriesReader<'r>,
    usize,
    usize,
);
impl<'t: 'r, 'r> ::core::iter::Iterator for BroadcastMessageQueriesReaderIterator<'t, 'r> {
    type Item = BroadcastMessageQueryReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for BroadcastMessageQueriesReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<BroadcastMessageQuery> for BroadcastMessageQueries {
    fn from_iter<T: IntoIterator<Item = BroadcastMessageQuery>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct QueryBroadcastMessages(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for QueryBroadcastMessages {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for QueryBroadcastMessages {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for QueryBroadcastMessages {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "queries", self.queries())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for QueryBroadcastMessages {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        QueryBroadcastMessages::new_unchecked(v)
    }
}
impl QueryBroadcastMessages {
    const DEFAULT_VALUE: [u8; 24] = [
        24, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn queries(&self) -> BroadcastMessageQueries {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BroadcastMessageQueries::new_unchecked(self.0.slice(start..end))
        } else {
            BroadcastMessageQueries::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> QueryBroadcastMessagesReader<'r> {
        QueryBroadcastMessagesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for QueryBroadcastMessages {
    type Builder = QueryBroadcastMessagesBuilder;
    const NAME: &'static str = "QueryBroadcastMessages";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        QueryBroadcastMessages(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        QueryBroadcastMessagesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        QueryBroadcastMessagesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().id(self.id()).queries(self.queries())
    }
}
#[derive(Clone, Copy)]
pub struct QueryBroadcastMessagesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for QueryBroadcastMessagesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for QueryBroadcastMessagesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for QueryBroadcastMessagesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "queries", self.queries())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> QueryBroadcastMessagesReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn queries(&self) -> BroadcastMessageQueriesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BroadcastMessageQueriesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BroadcastMessageQueriesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for QueryBroadcastMessagesReader<'r> {
    type Entity = QueryBroadcastMessages;
    const NAME: &'static str = "QueryBroadcastMessagesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        QueryBroadcastMessagesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BroadcastMessageQueriesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct QueryBroadcastMessagesBuilder {
    pub(crate) id: Uint64,
    pub(crate) queries: BroadcastMessageQueries,
}
impl QueryBroadcastMessagesBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn id(mut self, v: Uint64) -> Self {
        self.id = v;
        self
    }
    pub fn queries(mut self, v: BroadcastMessageQueries) -> Self {
        self.queries = v;
        self
    }
}
impl molecule::prelude::Builder for QueryBroadcastMessagesBuilder {
    type Entity = QueryBroadcastMessages;
    const NAME: &'static str = "QueryBroadcastMessagesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.id.as_slice().len()
            + self.queries.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.queries.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.queries.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        QueryBroadcastMessages::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct NodeAnnouncement(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NodeAnnouncement {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NodeAnnouncement {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NodeAnnouncement {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "signature", self.signature())?;
        write!(f, ", {}: {}", "features", self.features())?;
        write!(f, ", {}: {}", "timestamp", self.timestamp())?;
        write!(f, ", {}: {}", "node_id", self.node_id())?;
        write!(f, ", {}: {}", "alias", self.alias())?;
        write!(f, ", {}: {}", "address", self.address())?;
        write!(f, ", {}: {}", "chain_hash", self.chain_hash())?;
        write!(
            f,
            ", {}: {}",
            "auto_accept_min_ckb_funding_amount",
            self.auto_accept_min_ckb_funding_amount()
        )?;
        write!(f, ", {}: {}", "udt_cfg_infos", self.udt_cfg_infos())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for NodeAnnouncement {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        NodeAnnouncement::new_unchecked(v)
    }
}
impl NodeAnnouncement {
    const DEFAULT_VALUE: [u8; 173] = [
        173, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 93, 0, 0, 0, 125, 0, 0,
        0, 129, 0, 0, 0, 161, 0, 0, 0, 169, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 9;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn signature(&self) -> EcdsaSignature {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        EcdsaSignature::new_unchecked(self.0.slice(start..end))
    }
    pub fn features(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn timestamp(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn node_id(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn alias(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn address(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BytesVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn chain_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn auto_accept_min_ckb_funding_amount(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn udt_cfg_infos(&self) -> UdtCfgInfos {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[40..]) as usize;
            UdtCfgInfos::new_unchecked(self.0.slice(start..end))
        } else {
            UdtCfgInfos::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> NodeAnnouncementReader<'r> {
        NodeAnnouncementReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NodeAnnouncement {
    type Builder = NodeAnnouncementBuilder;
    const NAME: &'static str = "NodeAnnouncement";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NodeAnnouncement(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodeAnnouncementReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodeAnnouncementReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .signature(self.signature())
            .features(self.features())
            .timestamp(self.timestamp())
            .node_id(self.node_id())
            .alias(self.alias())
            .address(self.address())
            .chain_hash(self.chain_hash())
            .auto_accept_min_ckb_funding_amount(self.auto_accept_min_ckb_funding_amount())
            .udt_cfg_infos(self.udt_cfg_infos())
    }
}
#[derive(Clone, Copy)]
pub struct NodeAnnouncementReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NodeAnnouncementReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NodeAnnouncementReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NodeAnnouncementReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "signature", self.signature())?;
        write!(f, ", {}: {}", "features", self.features())?;
        write!(f, ", {}: {}", "timestamp", self.timestamp())?;
        write!(f, ", {}: {}", "node_id", self.node_id())?;
        write!(f, ", {}: {}", "alias", self.alias())?;
        write!(f, ", {}: {}", "address", self.address())?;
        write!(f, ", {}: {}", "chain_hash", self.chain_hash())?;
        write!(
            f,
            ", {}: {}",
            "auto_accept_min_ckb_funding_amount",
            self.auto_accept_min_ckb_funding_amount()
        )?;
        write!(f, ", {}: {}", "udt_cfg_infos", self.udt_cfg_infos())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> NodeAnnouncementReader<'r> {
    pub const FIELD_COUNT: usize = 9;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn signature(&self) -> EcdsaSignatureReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        EcdsaSignatureReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn features(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn timestamp(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn node_id(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn alias(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn address(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BytesVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn chain_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn auto_accept_min_ckb_funding_amount(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn udt_cfg_infos(&self) -> UdtCfgInfosReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[40..]) as usize;
            UdtCfgInfosReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            UdtCfgInfosReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for NodeAnnouncementReader<'r> {
    type Entity = NodeAnnouncement;
    const NAME: &'static str = "NodeAnnouncementReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NodeAnnouncementReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        EcdsaSignatureReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        PubkeyReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Byte32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BytesVecReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Byte32Reader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Uint64Reader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        UdtCfgInfosReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct NodeAnnouncementBuilder {
    pub(crate) signature: EcdsaSignature,
    pub(crate) features: Uint64,
    pub(crate) timestamp: Uint64,
    pub(crate) node_id: Pubkey,
    pub(crate) alias: Byte32,
    pub(crate) address: BytesVec,
    pub(crate) chain_hash: Byte32,
    pub(crate) auto_accept_min_ckb_funding_amount: Uint64,
    pub(crate) udt_cfg_infos: UdtCfgInfos,
}
impl NodeAnnouncementBuilder {
    pub const FIELD_COUNT: usize = 9;
    pub fn signature(mut self, v: EcdsaSignature) -> Self {
        self.signature = v;
        self
    }
    pub fn features(mut self, v: Uint64) -> Self {
        self.features = v;
        self
    }
    pub fn timestamp(mut self, v: Uint64) -> Self {
        self.timestamp = v;
        self
    }
    pub fn node_id(mut self, v: Pubkey) -> Self {
        self.node_id = v;
        self
    }
    pub fn alias(mut self, v: Byte32) -> Self {
        self.alias = v;
        self
    }
    pub fn address(mut self, v: BytesVec) -> Self {
        self.address = v;
        self
    }
    pub fn chain_hash(mut self, v: Byte32) -> Self {
        self.chain_hash = v;
        self
    }
    pub fn auto_accept_min_ckb_funding_amount(mut self, v: Uint64) -> Self {
        self.auto_accept_min_ckb_funding_amount = v;
        self
    }
    pub fn udt_cfg_infos(mut self, v: UdtCfgInfos) -> Self {
        self.udt_cfg_infos = v;
        self
    }
}
impl molecule::prelude::Builder for NodeAnnouncementBuilder {
    type Entity = NodeAnnouncement;
    const NAME: &'static str = "NodeAnnouncementBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.signature.as_slice().len()
            + self.features.as_slice().len()
            + self.timestamp.as_slice().len()
            + self.node_id.as_slice().len()
            + self.alias.as_slice().len()
            + self.address.as_slice().len()
            + self.chain_hash.as_slice().len()
            + self.auto_accept_min_ckb_funding_amount.as_slice().len()
            + self.udt_cfg_infos.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.signature.as_slice().len();
        offsets.push(total_size);
        total_size += self.features.as_slice().len();
        offsets.push(total_size);
        total_size += self.timestamp.as_slice().len();
        offsets.push(total_size);
        total_size += self.node_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.alias.as_slice().len();
        offsets.push(total_size);
        total_size += self.address.as_slice().len();
        offsets.push(total_size);
        total_size += self.chain_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.auto_accept_min_ckb_funding_amount.as_slice().len();
        offsets.push(total_size);
        total_size += self.udt_cfg_infos.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.signature.as_slice())?;
        writer.write_all(self.features.as_slice())?;
        writer.write_all(self.timestamp.as_slice())?;
        writer.write_all(self.node_id.as_slice())?;
        writer.write_all(self.alias.as_slice())?;
        writer.write_all(self.address.as_slice())?;
        writer.write_all(self.chain_hash.as_slice())?;
        writer.write_all(self.auto_accept_min_ckb_funding_amount.as_slice())?;
        writer.write_all(self.udt_cfg_infos.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NodeAnnouncement::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelAnnouncement(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelAnnouncement {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelAnnouncement {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelAnnouncement {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "node1_signature", self.node1_signature())?;
        write!(f, ", {}: {}", "node2_signature", self.node2_signature())?;
        write!(f, ", {}: {}", "ckb_signature", self.ckb_signature())?;
        write!(f, ", {}: {}", "features", self.features())?;
        write!(f, ", {}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "node1_id", self.node1_id())?;
        write!(f, ", {}: {}", "node2_id", self.node2_id())?;
        write!(f, ", {}: {}", "ckb_key", self.ckb_key())?;
        write!(f, ", {}: {}", "capacity", self.capacity())?;
        write!(f, ", {}: {}", "udt_type_script", self.udt_type_script())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelAnnouncement {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ChannelAnnouncement::new_unchecked(v)
    }
}
impl ChannelAnnouncement {
    const DEFAULT_VALUE: [u8; 310] = [
        54, 1, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 120, 0, 0, 0, 128, 0, 0, 0, 160, 0, 0,
        0, 196, 0, 0, 0, 229, 0, 0, 0, 6, 1, 0, 0, 38, 1, 0, 0, 54, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 11;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn node1_signature(&self) -> EcdsaSignature {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        EcdsaSignature::new_unchecked(self.0.slice(start..end))
    }
    pub fn node2_signature(&self) -> EcdsaSignature {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        EcdsaSignature::new_unchecked(self.0.slice(start..end))
    }
    pub fn ckb_signature(&self) -> SchnorrSignature {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        SchnorrSignature::new_unchecked(self.0.slice(start..end))
    }
    pub fn features(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn chain_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel_outpoint(&self) -> OutPoint {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        OutPoint::new_unchecked(self.0.slice(start..end))
    }
    pub fn node1_id(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn node2_id(&self) -> Pubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Pubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn ckb_key(&self) -> SchnorrXOnlyPubkey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        SchnorrXOnlyPubkey::new_unchecked(self.0.slice(start..end))
    }
    pub fn capacity(&self) -> Uint128 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Uint128::new_unchecked(self.0.slice(start..end))
    }
    pub fn udt_type_script(&self) -> ScriptOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[48..]) as usize;
            ScriptOpt::new_unchecked(self.0.slice(start..end))
        } else {
            ScriptOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelAnnouncementReader<'r> {
        ChannelAnnouncementReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelAnnouncement {
    type Builder = ChannelAnnouncementBuilder;
    const NAME: &'static str = "ChannelAnnouncement";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelAnnouncement(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelAnnouncementReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelAnnouncementReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .node1_signature(self.node1_signature())
            .node2_signature(self.node2_signature())
            .ckb_signature(self.ckb_signature())
            .features(self.features())
            .chain_hash(self.chain_hash())
            .channel_outpoint(self.channel_outpoint())
            .node1_id(self.node1_id())
            .node2_id(self.node2_id())
            .ckb_key(self.ckb_key())
            .capacity(self.capacity())
            .udt_type_script(self.udt_type_script())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelAnnouncementReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelAnnouncementReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelAnnouncementReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelAnnouncementReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "node1_signature", self.node1_signature())?;
        write!(f, ", {}: {}", "node2_signature", self.node2_signature())?;
        write!(f, ", {}: {}", "ckb_signature", self.ckb_signature())?;
        write!(f, ", {}: {}", "features", self.features())?;
        write!(f, ", {}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "node1_id", self.node1_id())?;
        write!(f, ", {}: {}", "node2_id", self.node2_id())?;
        write!(f, ", {}: {}", "ckb_key", self.ckb_key())?;
        write!(f, ", {}: {}", "capacity", self.capacity())?;
        write!(f, ", {}: {}", "udt_type_script", self.udt_type_script())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelAnnouncementReader<'r> {
    pub const FIELD_COUNT: usize = 11;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn node1_signature(&self) -> EcdsaSignatureReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        EcdsaSignatureReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn node2_signature(&self) -> EcdsaSignatureReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        EcdsaSignatureReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn ckb_signature(&self) -> SchnorrSignatureReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        SchnorrSignatureReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn features(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn chain_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel_outpoint(&self) -> OutPointReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        OutPointReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn node1_id(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn node2_id(&self) -> PubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        PubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn ckb_key(&self) -> SchnorrXOnlyPubkeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        SchnorrXOnlyPubkeyReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn capacity(&self) -> Uint128Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Uint128Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn udt_type_script(&self) -> ScriptOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[48..]) as usize;
            ScriptOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ScriptOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelAnnouncementReader<'r> {
    type Entity = ChannelAnnouncement;
    const NAME: &'static str = "ChannelAnnouncementReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelAnnouncementReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        EcdsaSignatureReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        EcdsaSignatureReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        SchnorrSignatureReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Byte32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        OutPointReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        PubkeyReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        PubkeyReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        SchnorrXOnlyPubkeyReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        Uint128Reader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        ScriptOptReader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ChannelAnnouncementBuilder {
    pub(crate) node1_signature: EcdsaSignature,
    pub(crate) node2_signature: EcdsaSignature,
    pub(crate) ckb_signature: SchnorrSignature,
    pub(crate) features: Uint64,
    pub(crate) chain_hash: Byte32,
    pub(crate) channel_outpoint: OutPoint,
    pub(crate) node1_id: Pubkey,
    pub(crate) node2_id: Pubkey,
    pub(crate) ckb_key: SchnorrXOnlyPubkey,
    pub(crate) capacity: Uint128,
    pub(crate) udt_type_script: ScriptOpt,
}
impl ChannelAnnouncementBuilder {
    pub const FIELD_COUNT: usize = 11;
    pub fn node1_signature(mut self, v: EcdsaSignature) -> Self {
        self.node1_signature = v;
        self
    }
    pub fn node2_signature(mut self, v: EcdsaSignature) -> Self {
        self.node2_signature = v;
        self
    }
    pub fn ckb_signature(mut self, v: SchnorrSignature) -> Self {
        self.ckb_signature = v;
        self
    }
    pub fn features(mut self, v: Uint64) -> Self {
        self.features = v;
        self
    }
    pub fn chain_hash(mut self, v: Byte32) -> Self {
        self.chain_hash = v;
        self
    }
    pub fn channel_outpoint(mut self, v: OutPoint) -> Self {
        self.channel_outpoint = v;
        self
    }
    pub fn node1_id(mut self, v: Pubkey) -> Self {
        self.node1_id = v;
        self
    }
    pub fn node2_id(mut self, v: Pubkey) -> Self {
        self.node2_id = v;
        self
    }
    pub fn ckb_key(mut self, v: SchnorrXOnlyPubkey) -> Self {
        self.ckb_key = v;
        self
    }
    pub fn capacity(mut self, v: Uint128) -> Self {
        self.capacity = v;
        self
    }
    pub fn udt_type_script(mut self, v: ScriptOpt) -> Self {
        self.udt_type_script = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelAnnouncementBuilder {
    type Entity = ChannelAnnouncement;
    const NAME: &'static str = "ChannelAnnouncementBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.node1_signature.as_slice().len()
            + self.node2_signature.as_slice().len()
            + self.ckb_signature.as_slice().len()
            + self.features.as_slice().len()
            + self.chain_hash.as_slice().len()
            + self.channel_outpoint.as_slice().len()
            + self.node1_id.as_slice().len()
            + self.node2_id.as_slice().len()
            + self.ckb_key.as_slice().len()
            + self.capacity.as_slice().len()
            + self.udt_type_script.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.node1_signature.as_slice().len();
        offsets.push(total_size);
        total_size += self.node2_signature.as_slice().len();
        offsets.push(total_size);
        total_size += self.ckb_signature.as_slice().len();
        offsets.push(total_size);
        total_size += self.features.as_slice().len();
        offsets.push(total_size);
        total_size += self.chain_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel_outpoint.as_slice().len();
        offsets.push(total_size);
        total_size += self.node1_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.node2_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.ckb_key.as_slice().len();
        offsets.push(total_size);
        total_size += self.capacity.as_slice().len();
        offsets.push(total_size);
        total_size += self.udt_type_script.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.node1_signature.as_slice())?;
        writer.write_all(self.node2_signature.as_slice())?;
        writer.write_all(self.ckb_signature.as_slice())?;
        writer.write_all(self.features.as_slice())?;
        writer.write_all(self.chain_hash.as_slice())?;
        writer.write_all(self.channel_outpoint.as_slice())?;
        writer.write_all(self.node1_id.as_slice())?;
        writer.write_all(self.node2_id.as_slice())?;
        writer.write_all(self.ckb_key.as_slice())?;
        writer.write_all(self.capacity.as_slice())?;
        writer.write_all(self.udt_type_script.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelAnnouncement::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelUpdate(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelUpdate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "signature", self.signature())?;
        write!(f, ", {}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "timestamp", self.timestamp())?;
        write!(f, ", {}: {}", "message_flags", self.message_flags())?;
        write!(f, ", {}: {}", "channel_flags", self.channel_flags())?;
        write!(f, ", {}: {}", "tlc_expiry_delta", self.tlc_expiry_delta())?;
        write!(f, ", {}: {}", "tlc_minimum_value", self.tlc_minimum_value())?;
        write!(f, ", {}: {}", "tlc_maximum_value", self.tlc_maximum_value())?;
        write!(
            f,
            ", {}: {}",
            "tlc_fee_proportional_millionths",
            self.tlc_fee_proportional_millionths()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelUpdate {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ChannelUpdate::new_unchecked(v)
    }
}
impl ChannelUpdate {
    const DEFAULT_VALUE: [u8; 188] = [
        188, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 116, 0, 0, 0, 124, 0, 0, 0, 128, 0, 0,
        0, 132, 0, 0, 0, 140, 0, 0, 0, 156, 0, 0, 0, 172, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 10;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn signature(&self) -> EcdsaSignature {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        EcdsaSignature::new_unchecked(self.0.slice(start..end))
    }
    pub fn chain_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel_outpoint(&self) -> OutPoint {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        OutPoint::new_unchecked(self.0.slice(start..end))
    }
    pub fn timestamp(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn message_flags(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn channel_flags(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn tlc_expiry_delta(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn tlc_minimum_value(&self) -> Uint128 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint128::new_unchecked(self.0.slice(start..end))
    }
    pub fn tlc_maximum_value(&self) -> Uint128 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Uint128::new_unchecked(self.0.slice(start..end))
    }
    pub fn tlc_fee_proportional_millionths(&self) -> Uint128 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[44..]) as usize;
            Uint128::new_unchecked(self.0.slice(start..end))
        } else {
            Uint128::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelUpdateReader<'r> {
        ChannelUpdateReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelUpdate {
    type Builder = ChannelUpdateBuilder;
    const NAME: &'static str = "ChannelUpdate";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelUpdate(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelUpdateReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelUpdateReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .signature(self.signature())
            .chain_hash(self.chain_hash())
            .channel_outpoint(self.channel_outpoint())
            .timestamp(self.timestamp())
            .message_flags(self.message_flags())
            .channel_flags(self.channel_flags())
            .tlc_expiry_delta(self.tlc_expiry_delta())
            .tlc_minimum_value(self.tlc_minimum_value())
            .tlc_maximum_value(self.tlc_maximum_value())
            .tlc_fee_proportional_millionths(self.tlc_fee_proportional_millionths())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelUpdateReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelUpdateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "signature", self.signature())?;
        write!(f, ", {}: {}", "chain_hash", self.chain_hash())?;
        write!(f, ", {}: {}", "channel_outpoint", self.channel_outpoint())?;
        write!(f, ", {}: {}", "timestamp", self.timestamp())?;
        write!(f, ", {}: {}", "message_flags", self.message_flags())?;
        write!(f, ", {}: {}", "channel_flags", self.channel_flags())?;
        write!(f, ", {}: {}", "tlc_expiry_delta", self.tlc_expiry_delta())?;
        write!(f, ", {}: {}", "tlc_minimum_value", self.tlc_minimum_value())?;
        write!(f, ", {}: {}", "tlc_maximum_value", self.tlc_maximum_value())?;
        write!(
            f,
            ", {}: {}",
            "tlc_fee_proportional_millionths",
            self.tlc_fee_proportional_millionths()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelUpdateReader<'r> {
    pub const FIELD_COUNT: usize = 10;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn signature(&self) -> EcdsaSignatureReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        EcdsaSignatureReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn chain_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel_outpoint(&self) -> OutPointReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        OutPointReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn timestamp(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn message_flags(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn channel_flags(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tlc_expiry_delta(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tlc_minimum_value(&self) -> Uint128Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Uint128Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tlc_maximum_value(&self) -> Uint128Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Uint128Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tlc_fee_proportional_millionths(&self) -> Uint128Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[44..]) as usize;
            Uint128Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint128Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelUpdateReader<'r> {
    type Entity = ChannelUpdate;
    const NAME: &'static str = "ChannelUpdateReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelUpdateReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        EcdsaSignatureReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        OutPointReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint32Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Uint64Reader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Uint128Reader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Uint128Reader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        Uint128Reader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ChannelUpdateBuilder {
    pub(crate) signature: EcdsaSignature,
    pub(crate) chain_hash: Byte32,
    pub(crate) channel_outpoint: OutPoint,
    pub(crate) timestamp: Uint64,
    pub(crate) message_flags: Uint32,
    pub(crate) channel_flags: Uint32,
    pub(crate) tlc_expiry_delta: Uint64,
    pub(crate) tlc_minimum_value: Uint128,
    pub(crate) tlc_maximum_value: Uint128,
    pub(crate) tlc_fee_proportional_millionths: Uint128,
}
impl ChannelUpdateBuilder {
    pub const FIELD_COUNT: usize = 10;
    pub fn signature(mut self, v: EcdsaSignature) -> Self {
        self.signature = v;
        self
    }
    pub fn chain_hash(mut self, v: Byte32) -> Self {
        self.chain_hash = v;
        self
    }
    pub fn channel_outpoint(mut self, v: OutPoint) -> Self {
        self.channel_outpoint = v;
        self
    }
    pub fn timestamp(mut self, v: Uint64) -> Self {
        self.timestamp = v;
        self
    }
    pub fn message_flags(mut self, v: Uint32) -> Self {
        self.message_flags = v;
        self
    }
    pub fn channel_flags(mut self, v: Uint32) -> Self {
        self.channel_flags = v;
        self
    }
    pub fn tlc_expiry_delta(mut self, v: Uint64) -> Self {
        self.tlc_expiry_delta = v;
        self
    }
    pub fn tlc_minimum_value(mut self, v: Uint128) -> Self {
        self.tlc_minimum_value = v;
        self
    }
    pub fn tlc_maximum_value(mut self, v: Uint128) -> Self {
        self.tlc_maximum_value = v;
        self
    }
    pub fn tlc_fee_proportional_millionths(mut self, v: Uint128) -> Self {
        self.tlc_fee_proportional_millionths = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelUpdateBuilder {
    type Entity = ChannelUpdate;
    const NAME: &'static str = "ChannelUpdateBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.signature.as_slice().len()
            + self.chain_hash.as_slice().len()
            + self.channel_outpoint.as_slice().len()
            + self.timestamp.as_slice().len()
            + self.message_flags.as_slice().len()
            + self.channel_flags.as_slice().len()
            + self.tlc_expiry_delta.as_slice().len()
            + self.tlc_minimum_value.as_slice().len()
            + self.tlc_maximum_value.as_slice().len()
            + self.tlc_fee_proportional_millionths.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.signature.as_slice().len();
        offsets.push(total_size);
        total_size += self.chain_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel_outpoint.as_slice().len();
        offsets.push(total_size);
        total_size += self.timestamp.as_slice().len();
        offsets.push(total_size);
        total_size += self.message_flags.as_slice().len();
        offsets.push(total_size);
        total_size += self.channel_flags.as_slice().len();
        offsets.push(total_size);
        total_size += self.tlc_expiry_delta.as_slice().len();
        offsets.push(total_size);
        total_size += self.tlc_minimum_value.as_slice().len();
        offsets.push(total_size);
        total_size += self.tlc_maximum_value.as_slice().len();
        offsets.push(total_size);
        total_size += self.tlc_fee_proportional_millionths.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.signature.as_slice())?;
        writer.write_all(self.chain_hash.as_slice())?;
        writer.write_all(self.channel_outpoint.as_slice())?;
        writer.write_all(self.timestamp.as_slice())?;
        writer.write_all(self.message_flags.as_slice())?;
        writer.write_all(self.channel_flags.as_slice())?;
        writer.write_all(self.tlc_expiry_delta.as_slice())?;
        writer.write_all(self.tlc_minimum_value.as_slice())?;
        writer.write_all(self.tlc_maximum_value.as_slice())?;
        writer.write_all(self.tlc_fee_proportional_millionths.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelUpdate::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BroadcastMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BroadcastMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BroadcastMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BroadcastMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for BroadcastMessage {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BroadcastMessage::new_unchecked(v)
    }
}
impl BroadcastMessage {
    const DEFAULT_VALUE: [u8; 177] = [
        0, 0, 0, 0, 173, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 93, 0, 0, 0,
        125, 0, 0, 0, 129, 0, 0, 0, 161, 0, 0, 0, 169, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,
        0,
    ];
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BroadcastMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => NodeAnnouncement::new_unchecked(inner).into(),
            1 => ChannelAnnouncement::new_unchecked(inner).into(),
            2 => ChannelUpdate::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> BroadcastMessageReader<'r> {
        BroadcastMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BroadcastMessage {
    type Builder = BroadcastMessageBuilder;
    const NAME: &'static str = "BroadcastMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BroadcastMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct BroadcastMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BroadcastMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BroadcastMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BroadcastMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> BroadcastMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BroadcastMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => NodeAnnouncementReader::new_unchecked(inner).into(),
            1 => ChannelAnnouncementReader::new_unchecked(inner).into(),
            2 => ChannelUpdateReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BroadcastMessageReader<'r> {
    type Entity = BroadcastMessage;
    const NAME: &'static str = "BroadcastMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BroadcastMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => NodeAnnouncementReader::verify(inner_slice, compatible),
            1 => ChannelAnnouncementReader::verify(inner_slice, compatible),
            2 => ChannelUpdateReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BroadcastMessageBuilder(pub(crate) BroadcastMessageUnion);
impl BroadcastMessageBuilder {
    pub const ITEMS_COUNT: usize = 3;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<BroadcastMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for BroadcastMessageBuilder {
    type Entity = BroadcastMessage;
    const NAME: &'static str = "BroadcastMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BroadcastMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum BroadcastMessageUnion {
    NodeAnnouncement(NodeAnnouncement),
    ChannelAnnouncement(ChannelAnnouncement),
    ChannelUpdate(ChannelUpdate),
}
#[derive(Debug, Clone, Copy)]
pub enum BroadcastMessageUnionReader<'r> {
    NodeAnnouncement(NodeAnnouncementReader<'r>),
    ChannelAnnouncement(ChannelAnnouncementReader<'r>),
    ChannelUpdate(ChannelUpdateReader<'r>),
}
impl ::core::default::Default for BroadcastMessageUnion {
    fn default() -> Self {
        BroadcastMessageUnion::NodeAnnouncement(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for BroadcastMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BroadcastMessageUnion::NodeAnnouncement(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NodeAnnouncement::NAME, item)
            }
            BroadcastMessageUnion::ChannelAnnouncement(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ChannelAnnouncement::NAME, item)
            }
            BroadcastMessageUnion::ChannelUpdate(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ChannelUpdate::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for BroadcastMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BroadcastMessageUnionReader::NodeAnnouncement(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NodeAnnouncement::NAME, item)
            }
            BroadcastMessageUnionReader::ChannelAnnouncement(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ChannelAnnouncement::NAME, item)
            }
            BroadcastMessageUnionReader::ChannelUpdate(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ChannelUpdate::NAME, item)
            }
        }
    }
}
impl BroadcastMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BroadcastMessageUnion::NodeAnnouncement(ref item) => write!(f, "{}", item),
            BroadcastMessageUnion::ChannelAnnouncement(ref item) => write!(f, "{}", item),
            BroadcastMessageUnion::ChannelUpdate(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> BroadcastMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BroadcastMessageUnionReader::NodeAnnouncement(ref item) => write!(f, "{}", item),
            BroadcastMessageUnionReader::ChannelAnnouncement(ref item) => write!(f, "{}", item),
            BroadcastMessageUnionReader::ChannelUpdate(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<NodeAnnouncement> for BroadcastMessageUnion {
    fn from(item: NodeAnnouncement) -> Self {
        BroadcastMessageUnion::NodeAnnouncement(item)
    }
}
impl ::core::convert::From<ChannelAnnouncement> for BroadcastMessageUnion {
    fn from(item: ChannelAnnouncement) -> Self {
        BroadcastMessageUnion::ChannelAnnouncement(item)
    }
}
impl ::core::convert::From<ChannelUpdate> for BroadcastMessageUnion {
    fn from(item: ChannelUpdate) -> Self {
        BroadcastMessageUnion::ChannelUpdate(item)
    }
}
impl<'r> ::core::convert::From<NodeAnnouncementReader<'r>> for BroadcastMessageUnionReader<'r> {
    fn from(item: NodeAnnouncementReader<'r>) -> Self {
        BroadcastMessageUnionReader::NodeAnnouncement(item)
    }
}
impl<'r> ::core::convert::From<ChannelAnnouncementReader<'r>> for BroadcastMessageUnionReader<'r> {
    fn from(item: ChannelAnnouncementReader<'r>) -> Self {
        BroadcastMessageUnionReader::ChannelAnnouncement(item)
    }
}
impl<'r> ::core::convert::From<ChannelUpdateReader<'r>> for BroadcastMessageUnionReader<'r> {
    fn from(item: ChannelUpdateReader<'r>) -> Self {
        BroadcastMessageUnionReader::ChannelUpdate(item)
    }
}
impl BroadcastMessageUnion {
    pub const NAME: &'static str = "BroadcastMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            BroadcastMessageUnion::NodeAnnouncement(item) => item.as_bytes(),
            BroadcastMessageUnion::ChannelAnnouncement(item) => item.as_bytes(),
            BroadcastMessageUnion::ChannelUpdate(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            BroadcastMessageUnion::NodeAnnouncement(item) => item.as_slice(),
            BroadcastMessageUnion::ChannelAnnouncement(item) => item.as_slice(),
            BroadcastMessageUnion::ChannelUpdate(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BroadcastMessageUnion::NodeAnnouncement(_) => 0,
            BroadcastMessageUnion::ChannelAnnouncement(_) => 1,
            BroadcastMessageUnion::ChannelUpdate(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BroadcastMessageUnion::NodeAnnouncement(_) => "NodeAnnouncement",
            BroadcastMessageUnion::ChannelAnnouncement(_) => "ChannelAnnouncement",
            BroadcastMessageUnion::ChannelUpdate(_) => "ChannelUpdate",
        }
    }
    pub fn as_reader<'r>(&'r self) -> BroadcastMessageUnionReader<'r> {
        match self {
            BroadcastMessageUnion::NodeAnnouncement(item) => item.as_reader().into(),
            BroadcastMessageUnion::ChannelAnnouncement(item) => item.as_reader().into(),
            BroadcastMessageUnion::ChannelUpdate(item) => item.as_reader().into(),
        }
    }
}
impl<'r> BroadcastMessageUnionReader<'r> {
    pub const NAME: &'r str = "BroadcastMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            BroadcastMessageUnionReader::NodeAnnouncement(item) => item.as_slice(),
            BroadcastMessageUnionReader::ChannelAnnouncement(item) => item.as_slice(),
            BroadcastMessageUnionReader::ChannelUpdate(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BroadcastMessageUnionReader::NodeAnnouncement(_) => 0,
            BroadcastMessageUnionReader::ChannelAnnouncement(_) => 1,
            BroadcastMessageUnionReader::ChannelUpdate(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BroadcastMessageUnionReader::NodeAnnouncement(_) => "NodeAnnouncement",
            BroadcastMessageUnionReader::ChannelAnnouncement(_) => "ChannelAnnouncement",
            BroadcastMessageUnionReader::ChannelUpdate(_) => "ChannelUpdate",
        }
    }
}
impl From<NodeAnnouncement> for BroadcastMessage {
    fn from(value: NodeAnnouncement) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<ChannelAnnouncement> for BroadcastMessage {
    fn from(value: ChannelAnnouncement) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<ChannelUpdate> for BroadcastMessage {
    fn from(value: ChannelUpdate) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct BroadcastMessages(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BroadcastMessages {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BroadcastMessages {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BroadcastMessages {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for BroadcastMessages {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BroadcastMessages::new_unchecked(v)
    }
}
impl BroadcastMessages {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<BroadcastMessage> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> BroadcastMessage {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            BroadcastMessage::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            BroadcastMessage::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BroadcastMessagesReader<'r> {
        BroadcastMessagesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BroadcastMessages {
    type Builder = BroadcastMessagesBuilder;
    const NAME: &'static str = "BroadcastMessages";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BroadcastMessages(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessagesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessagesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct BroadcastMessagesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BroadcastMessagesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BroadcastMessagesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BroadcastMessagesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> BroadcastMessagesReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<BroadcastMessageReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> BroadcastMessageReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            BroadcastMessageReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            BroadcastMessageReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BroadcastMessagesReader<'r> {
    type Entity = BroadcastMessages;
    const NAME: &'static str = "BroadcastMessagesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BroadcastMessagesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            BroadcastMessageReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BroadcastMessagesBuilder(pub(crate) Vec<BroadcastMessage>);
impl BroadcastMessagesBuilder {
    pub fn set(mut self, v: Vec<BroadcastMessage>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: BroadcastMessage) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = BroadcastMessage>>(
        mut self,
        iter: T,
    ) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: BroadcastMessage) -> Option<BroadcastMessage> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for BroadcastMessagesBuilder {
    type Entity = BroadcastMessages;
    const NAME: &'static str = "BroadcastMessagesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BroadcastMessages::new_unchecked(inner.into())
    }
}
pub struct BroadcastMessagesIterator(BroadcastMessages, usize, usize);
impl ::core::iter::Iterator for BroadcastMessagesIterator {
    type Item = BroadcastMessage;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for BroadcastMessagesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for BroadcastMessages {
    type Item = BroadcastMessage;
    type IntoIter = BroadcastMessagesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BroadcastMessagesIterator(self, 0, len)
    }
}
impl<'r> BroadcastMessagesReader<'r> {
    pub fn iter<'t>(&'t self) -> BroadcastMessagesReaderIterator<'t, 'r> {
        BroadcastMessagesReaderIterator(&self, 0, self.len())
    }
}
pub struct BroadcastMessagesReaderIterator<'t, 'r>(&'t BroadcastMessagesReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for BroadcastMessagesReaderIterator<'t, 'r> {
    type Item = BroadcastMessageReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for BroadcastMessagesReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<BroadcastMessage> for BroadcastMessages {
    fn from_iter<T: IntoIterator<Item = BroadcastMessage>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct BroadcastMessagesResult(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BroadcastMessagesResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BroadcastMessagesResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BroadcastMessagesResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "messages", self.messages())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BroadcastMessagesResult {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BroadcastMessagesResult::new_unchecked(v)
    }
}
impl BroadcastMessagesResult {
    const DEFAULT_VALUE: [u8; 24] = [
        24, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn messages(&self) -> BroadcastMessages {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BroadcastMessages::new_unchecked(self.0.slice(start..end))
        } else {
            BroadcastMessages::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BroadcastMessagesResultReader<'r> {
        BroadcastMessagesResultReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BroadcastMessagesResult {
    type Builder = BroadcastMessagesResultBuilder;
    const NAME: &'static str = "BroadcastMessagesResult";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BroadcastMessagesResult(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessagesResultReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BroadcastMessagesResultReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().id(self.id()).messages(self.messages())
    }
}
#[derive(Clone, Copy)]
pub struct BroadcastMessagesResultReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BroadcastMessagesResultReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BroadcastMessagesResultReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BroadcastMessagesResultReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "messages", self.messages())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BroadcastMessagesResultReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn id(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn messages(&self) -> BroadcastMessagesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BroadcastMessagesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BroadcastMessagesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BroadcastMessagesResultReader<'r> {
    type Entity = BroadcastMessagesResult;
    const NAME: &'static str = "BroadcastMessagesResultReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BroadcastMessagesResultReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BroadcastMessagesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BroadcastMessagesResultBuilder {
    pub(crate) id: Uint64,
    pub(crate) messages: BroadcastMessages,
}
impl BroadcastMessagesResultBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn id(mut self, v: Uint64) -> Self {
        self.id = v;
        self
    }
    pub fn messages(mut self, v: BroadcastMessages) -> Self {
        self.messages = v;
        self
    }
}
impl molecule::prelude::Builder for BroadcastMessagesResultBuilder {
    type Entity = BroadcastMessagesResult;
    const NAME: &'static str = "BroadcastMessagesResultBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.id.as_slice().len()
            + self.messages.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.messages.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.messages.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BroadcastMessagesResult::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GossipMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GossipMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GossipMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GossipMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for GossipMessage {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GossipMessage::new_unchecked(v)
    }
}
impl GossipMessage {
    const DEFAULT_VALUE: [u8; 28] = [
        0, 0, 0, 0, 24, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 4;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> GossipMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => BroadcastMessagesResult::new_unchecked(inner).into(),
            1 => BroadcastMessagesFilter::new_unchecked(inner).into(),
            2 => GetBroadcastMessages::new_unchecked(inner).into(),
            3 => QueryBroadcastMessages::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> GossipMessageReader<'r> {
        GossipMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GossipMessage {
    type Builder = GossipMessageBuilder;
    const NAME: &'static str = "GossipMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GossipMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GossipMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GossipMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct GossipMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GossipMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GossipMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GossipMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> GossipMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 4;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> GossipMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => BroadcastMessagesResultReader::new_unchecked(inner).into(),
            1 => BroadcastMessagesFilterReader::new_unchecked(inner).into(),
            2 => GetBroadcastMessagesReader::new_unchecked(inner).into(),
            3 => QueryBroadcastMessagesReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GossipMessageReader<'r> {
    type Entity = GossipMessage;
    const NAME: &'static str = "GossipMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GossipMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => BroadcastMessagesResultReader::verify(inner_slice, compatible),
            1 => BroadcastMessagesFilterReader::verify(inner_slice, compatible),
            2 => GetBroadcastMessagesReader::verify(inner_slice, compatible),
            3 => QueryBroadcastMessagesReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct GossipMessageBuilder(pub(crate) GossipMessageUnion);
impl GossipMessageBuilder {
    pub const ITEMS_COUNT: usize = 4;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<GossipMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for GossipMessageBuilder {
    type Entity = GossipMessage;
    const NAME: &'static str = "GossipMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GossipMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum GossipMessageUnion {
    BroadcastMessagesResult(BroadcastMessagesResult),
    BroadcastMessagesFilter(BroadcastMessagesFilter),
    GetBroadcastMessages(GetBroadcastMessages),
    QueryBroadcastMessages(QueryBroadcastMessages),
}
#[derive(Debug, Clone, Copy)]
pub enum GossipMessageUnionReader<'r> {
    BroadcastMessagesResult(BroadcastMessagesResultReader<'r>),
    BroadcastMessagesFilter(BroadcastMessagesFilterReader<'r>),
    GetBroadcastMessages(GetBroadcastMessagesReader<'r>),
    QueryBroadcastMessages(QueryBroadcastMessagesReader<'r>),
}
impl ::core::default::Default for GossipMessageUnion {
    fn default() -> Self {
        GossipMessageUnion::BroadcastMessagesResult(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for GossipMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            GossipMessageUnion::BroadcastMessagesResult(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    BroadcastMessagesResult::NAME,
                    item
                )
            }
            GossipMessageUnion::BroadcastMessagesFilter(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    BroadcastMessagesFilter::NAME,
                    item
                )
            }
            GossipMessageUnion::GetBroadcastMessages(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBroadcastMessages::NAME,
                    item
                )
            }
            GossipMessageUnion::QueryBroadcastMessages(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    QueryBroadcastMessages::NAME,
                    item
                )
            }
        }
    }
}
impl<'r> ::core::fmt::Display for GossipMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            GossipMessageUnionReader::BroadcastMessagesResult(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    BroadcastMessagesResult::NAME,
                    item
                )
            }
            GossipMessageUnionReader::BroadcastMessagesFilter(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    BroadcastMessagesFilter::NAME,
                    item
                )
            }
            GossipMessageUnionReader::GetBroadcastMessages(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBroadcastMessages::NAME,
                    item
                )
            }
            GossipMessageUnionReader::QueryBroadcastMessages(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    QueryBroadcastMessages::NAME,
                    item
                )
            }
        }
    }
}
impl GossipMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            GossipMessageUnion::BroadcastMessagesResult(ref item) => write!(f, "{}", item),
            GossipMessageUnion::BroadcastMessagesFilter(ref item) => write!(f, "{}", item),
            GossipMessageUnion::GetBroadcastMessages(ref item) => write!(f, "{}", item),
            GossipMessageUnion::QueryBroadcastMessages(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> GossipMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            GossipMessageUnionReader::BroadcastMessagesResult(ref item) => write!(f, "{}", item),
            GossipMessageUnionReader::BroadcastMessagesFilter(ref item) => write!(f, "{}", item),
            GossipMessageUnionReader::GetBroadcastMessages(ref item) => write!(f, "{}", item),
            GossipMessageUnionReader::QueryBroadcastMessages(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<BroadcastMessagesResult> for GossipMessageUnion {
    fn from(item: BroadcastMessagesResult) -> Self {
        GossipMessageUnion::BroadcastMessagesResult(item)
    }
}
impl ::core::convert::From<BroadcastMessagesFilter> for GossipMessageUnion {
    fn from(item: BroadcastMessagesFilter) -> Self {
        GossipMessageUnion::BroadcastMessagesFilter(item)
    }
}
impl ::core::convert::From<GetBroadcastMessages> for GossipMessageUnion {
    fn from(item: GetBroadcastMessages) -> Self {
        GossipMessageUnion::GetBroadcastMessages(item)
    }
}
impl ::core::convert::From<QueryBroadcastMessages> for GossipMessageUnion {
    fn from(item: QueryBroadcastMessages) -> Self {
        GossipMessageUnion::QueryBroadcastMessages(item)
    }
}
impl<'r> ::core::convert::From<BroadcastMessagesResultReader<'r>> for GossipMessageUnionReader<'r> {
    fn from(item: BroadcastMessagesResultReader<'r>) -> Self {
        GossipMessageUnionReader::BroadcastMessagesResult(item)
    }
}
impl<'r> ::core::convert::From<BroadcastMessagesFilterReader<'r>> for GossipMessageUnionReader<'r> {
    fn from(item: BroadcastMessagesFilterReader<'r>) -> Self {
        GossipMessageUnionReader::BroadcastMessagesFilter(item)
    }
}
impl<'r> ::core::convert::From<GetBroadcastMessagesReader<'r>> for GossipMessageUnionReader<'r> {
    fn from(item: GetBroadcastMessagesReader<'r>) -> Self {
        GossipMessageUnionReader::GetBroadcastMessages(item)
    }
}
impl<'r> ::core::convert::From<QueryBroadcastMessagesReader<'r>> for GossipMessageUnionReader<'r> {
    fn from(item: QueryBroadcastMessagesReader<'r>) -> Self {
        GossipMessageUnionReader::QueryBroadcastMessages(item)
    }
}
impl GossipMessageUnion {
    pub const NAME: &'static str = "GossipMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            GossipMessageUnion::BroadcastMessagesResult(item) => item.as_bytes(),
            GossipMessageUnion::BroadcastMessagesFilter(item) => item.as_bytes(),
            GossipMessageUnion::GetBroadcastMessages(item) => item.as_bytes(),
            GossipMessageUnion::QueryBroadcastMessages(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            GossipMessageUnion::BroadcastMessagesResult(item) => item.as_slice(),
            GossipMessageUnion::BroadcastMessagesFilter(item) => item.as_slice(),
            GossipMessageUnion::GetBroadcastMessages(item) => item.as_slice(),
            GossipMessageUnion::QueryBroadcastMessages(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            GossipMessageUnion::BroadcastMessagesResult(_) => 0,
            GossipMessageUnion::BroadcastMessagesFilter(_) => 1,
            GossipMessageUnion::GetBroadcastMessages(_) => 2,
            GossipMessageUnion::QueryBroadcastMessages(_) => 3,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            GossipMessageUnion::BroadcastMessagesResult(_) => "BroadcastMessagesResult",
            GossipMessageUnion::BroadcastMessagesFilter(_) => "BroadcastMessagesFilter",
            GossipMessageUnion::GetBroadcastMessages(_) => "GetBroadcastMessages",
            GossipMessageUnion::QueryBroadcastMessages(_) => "QueryBroadcastMessages",
        }
    }
    pub fn as_reader<'r>(&'r self) -> GossipMessageUnionReader<'r> {
        match self {
            GossipMessageUnion::BroadcastMessagesResult(item) => item.as_reader().into(),
            GossipMessageUnion::BroadcastMessagesFilter(item) => item.as_reader().into(),
            GossipMessageUnion::GetBroadcastMessages(item) => item.as_reader().into(),
            GossipMessageUnion::QueryBroadcastMessages(item) => item.as_reader().into(),
        }
    }
}
impl<'r> GossipMessageUnionReader<'r> {
    pub const NAME: &'r str = "GossipMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            GossipMessageUnionReader::BroadcastMessagesResult(item) => item.as_slice(),
            GossipMessageUnionReader::BroadcastMessagesFilter(item) => item.as_slice(),
            GossipMessageUnionReader::GetBroadcastMessages(item) => item.as_slice(),
            GossipMessageUnionReader::QueryBroadcastMessages(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            GossipMessageUnionReader::BroadcastMessagesResult(_) => 0,
            GossipMessageUnionReader::BroadcastMessagesFilter(_) => 1,
            GossipMessageUnionReader::GetBroadcastMessages(_) => 2,
            GossipMessageUnionReader::QueryBroadcastMessages(_) => 3,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            GossipMessageUnionReader::BroadcastMessagesResult(_) => "BroadcastMessagesResult",
            GossipMessageUnionReader::BroadcastMessagesFilter(_) => "BroadcastMessagesFilter",
            GossipMessageUnionReader::GetBroadcastMessages(_) => "GetBroadcastMessages",
            GossipMessageUnionReader::QueryBroadcastMessages(_) => "QueryBroadcastMessages",
        }
    }
}
impl From<BroadcastMessagesResult> for GossipMessage {
    fn from(value: BroadcastMessagesResult) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<BroadcastMessagesFilter> for GossipMessage {
    fn from(value: BroadcastMessagesFilter) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<GetBroadcastMessages> for GossipMessage {
    fn from(value: GetBroadcastMessages) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<QueryBroadcastMessages> for GossipMessage {
    fn from(value: QueryBroadcastMessages) -> Self {
        Self::new_builder().set(value).build()
    }
}
